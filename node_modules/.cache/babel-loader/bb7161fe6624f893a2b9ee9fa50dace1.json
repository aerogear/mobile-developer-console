{"ast":null,"code":"/**\n * A Javascript implementation of AES Cipher Suites for TLS.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2015 Digital Bazaar, Inc.\n *\n */\nvar forge = require('./forge');\n\nrequire('./aes');\n\nrequire('./tls');\n\nvar tls = module.exports = forge.tls;\n/**\n * Supported cipher suites.\n */\n\ntls.CipherSuites['TLS_RSA_WITH_AES_128_CBC_SHA'] = {\n  id: [0x00, 0x2f],\n  name: 'TLS_RSA_WITH_AES_128_CBC_SHA',\n  initSecurityParameters: function initSecurityParameters(sp) {\n    sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\n    sp.cipher_type = tls.CipherType.block;\n    sp.enc_key_length = 16;\n    sp.block_length = 16;\n    sp.fixed_iv_length = 16;\n    sp.record_iv_length = 16;\n    sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\n    sp.mac_length = 20;\n    sp.mac_key_length = 20;\n  },\n  initConnectionState: initConnectionState\n};\ntls.CipherSuites['TLS_RSA_WITH_AES_256_CBC_SHA'] = {\n  id: [0x00, 0x35],\n  name: 'TLS_RSA_WITH_AES_256_CBC_SHA',\n  initSecurityParameters: function initSecurityParameters(sp) {\n    sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;\n    sp.cipher_type = tls.CipherType.block;\n    sp.enc_key_length = 32;\n    sp.block_length = 16;\n    sp.fixed_iv_length = 16;\n    sp.record_iv_length = 16;\n    sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;\n    sp.mac_length = 20;\n    sp.mac_key_length = 20;\n  },\n  initConnectionState: initConnectionState\n};\n\nfunction initConnectionState(state, c, sp) {\n  var client = c.entity === forge.tls.ConnectionEnd.client; // cipher setup\n\n  state.read.cipherState = {\n    init: false,\n    cipher: forge.cipher.createDecipher('AES-CBC', client ? sp.keys.server_write_key : sp.keys.client_write_key),\n    iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV\n  };\n  state.write.cipherState = {\n    init: false,\n    cipher: forge.cipher.createCipher('AES-CBC', client ? sp.keys.client_write_key : sp.keys.server_write_key),\n    iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV\n  };\n  state.read.cipherFunction = decrypt_aes_cbc_sha1;\n  state.write.cipherFunction = encrypt_aes_cbc_sha1; // MAC setup\n\n  state.read.macLength = state.write.macLength = sp.mac_length;\n  state.read.macFunction = state.write.macFunction = tls.hmac_sha1;\n}\n/**\n * Encrypts the TLSCompressed record into a TLSCipherText record using AES\n * in CBC mode.\n *\n * @param record the TLSCompressed record to encrypt.\n * @param s the ConnectionState to use.\n *\n * @return true on success, false on failure.\n */\n\n\nfunction encrypt_aes_cbc_sha1(record, s) {\n  var rval = false; // append MAC to fragment, update sequence number\n\n  var mac = s.macFunction(s.macKey, s.sequenceNumber, record);\n  record.fragment.putBytes(mac);\n  s.updateSequenceNumber(); // TLS 1.1+ use an explicit IV every time to protect against CBC attacks\n\n  var iv;\n\n  if (record.version.minor === tls.Versions.TLS_1_0.minor) {\n    // use the pre-generated IV when initializing for TLS 1.0, otherwise use\n    // the residue from the previous encryption\n    iv = s.cipherState.init ? null : s.cipherState.iv;\n  } else {\n    iv = forge.random.getBytesSync(16);\n  }\n\n  s.cipherState.init = true; // start cipher\n\n  var cipher = s.cipherState.cipher;\n  cipher.start({\n    iv: iv\n  }); // TLS 1.1+ write IV into output\n\n  if (record.version.minor >= tls.Versions.TLS_1_1.minor) {\n    cipher.output.putBytes(iv);\n  } // do encryption (default padding is appropriate)\n\n\n  cipher.update(record.fragment);\n\n  if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {\n    // set record fragment to encrypted output\n    record.fragment = cipher.output;\n    record.length = record.fragment.length();\n    rval = true;\n  }\n\n  return rval;\n}\n/**\n * Handles padding for aes_cbc_sha1 in encrypt mode.\n *\n * @param blockSize the block size.\n * @param input the input buffer.\n * @param decrypt true in decrypt mode, false in encrypt mode.\n *\n * @return true on success, false on failure.\n */\n\n\nfunction encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {\n  /* The encrypted data length (TLSCiphertext.length) is one more than the sum\n   of SecurityParameters.block_length, TLSCompressed.length,\n   SecurityParameters.mac_length, and padding_length.\n    The padding may be any length up to 255 bytes long, as long as it results in\n   the TLSCiphertext.length being an integral multiple of the block length.\n   Lengths longer than necessary might be desirable to frustrate attacks on a\n   protocol based on analysis of the lengths of exchanged messages. Each uint8\n   in the padding data vector must be filled with the padding length value.\n    The padding length should be such that the total size of the\n   GenericBlockCipher structure is a multiple of the cipher's block length.\n   Legal values range from zero to 255, inclusive. This length specifies the\n   length of the padding field exclusive of the padding_length field itself.\n    This is slightly different from PKCS#7 because the padding value is 1\n   less than the actual number of padding bytes if you include the\n   padding_length uint8 itself as a padding byte. */\n  if (!decrypt) {\n    // get the number of padding bytes required to reach the blockSize and\n    // subtract 1 for the padding value (to make room for the padding_length\n    // uint8)\n    var padding = blockSize - input.length() % blockSize;\n    input.fillWithByte(padding - 1, padding);\n  }\n\n  return true;\n}\n/**\n * Handles padding for aes_cbc_sha1 in decrypt mode.\n *\n * @param blockSize the block size.\n * @param output the output buffer.\n * @param decrypt true in decrypt mode, false in encrypt mode.\n *\n * @return true on success, false on failure.\n */\n\n\nfunction decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {\n  var rval = true;\n\n  if (decrypt) {\n    /* The last byte in the output specifies the number of padding bytes not\n      including itself. Each of the padding bytes has the same value as that\n      last byte (known as the padding_length). Here we check all padding\n      bytes to ensure they have the value of padding_length even if one of\n      them is bad in order to ward-off timing attacks. */\n    var len = output.length();\n    var paddingLength = output.last();\n\n    for (var i = len - 1 - paddingLength; i < len - 1; ++i) {\n      rval = rval && output.at(i) == paddingLength;\n    }\n\n    if (rval) {\n      // trim off padding bytes and last padding length byte\n      output.truncate(paddingLength + 1);\n    }\n  }\n\n  return rval;\n}\n/**\n * Decrypts a TLSCipherText record into a TLSCompressed record using\n * AES in CBC mode.\n *\n * @param record the TLSCipherText record to decrypt.\n * @param s the ConnectionState to use.\n *\n * @return true on success, false on failure.\n */\n\n\nfunction decrypt_aes_cbc_sha1(record, s) {\n  var rval = false;\n  var iv;\n\n  if (record.version.minor === tls.Versions.TLS_1_0.minor) {\n    // use pre-generated IV when initializing for TLS 1.0, otherwise use the\n    // residue from the previous decryption\n    iv = s.cipherState.init ? null : s.cipherState.iv;\n  } else {\n    // TLS 1.1+ use an explicit IV every time to protect against CBC attacks\n    // that is appended to the record fragment\n    iv = record.fragment.getBytes(16);\n  }\n\n  s.cipherState.init = true; // start cipher\n\n  var cipher = s.cipherState.cipher;\n  cipher.start({\n    iv: iv\n  }); // do decryption\n\n  cipher.update(record.fragment);\n  rval = cipher.finish(decrypt_aes_cbc_sha1_padding); // even if decryption fails, keep going to minimize timing attacks\n  // decrypted data:\n  // first (len - 20) bytes = application data\n  // last 20 bytes          = MAC\n\n  var macLen = s.macLength; // create a random MAC to check against should the mac length check fail\n  // Note: do this regardless of the failure to keep timing consistent\n\n  var mac = forge.random.getBytesSync(macLen); // get fragment and mac\n\n  var len = cipher.output.length();\n\n  if (len >= macLen) {\n    record.fragment = cipher.output.getBytes(len - macLen);\n    mac = cipher.output.getBytes(macLen);\n  } else {\n    // bad data, but get bytes anyway to try to keep timing consistent\n    record.fragment = cipher.output.getBytes();\n  }\n\n  record.fragment = forge.util.createBuffer(record.fragment);\n  record.length = record.fragment.length(); // see if data integrity checks out, update sequence number\n\n  var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);\n  s.updateSequenceNumber();\n  rval = compareMacs(s.macKey, mac, mac2) && rval;\n  return rval;\n}\n/**\n * Safely compare two MACs. This function will compare two MACs in a way\n * that protects against timing attacks.\n *\n * TODO: Expose elsewhere as a utility API.\n *\n * See: https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/\n *\n * @param key the MAC key to use.\n * @param mac1 as a binary-encoded string of bytes.\n * @param mac2 as a binary-encoded string of bytes.\n *\n * @return true if the MACs are the same, false if not.\n */\n\n\nfunction compareMacs(key, mac1, mac2) {\n  var hmac = forge.hmac.create();\n  hmac.start('SHA1', key);\n  hmac.update(mac1);\n  mac1 = hmac.digest().getBytes();\n  hmac.start(null, null);\n  hmac.update(mac2);\n  mac2 = hmac.digest().getBytes();\n  return mac1 === mac2;\n}","map":null,"metadata":{},"sourceType":"script"}